// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "google/fhir/json/json_sax_handler.h"

#include <cstddef>
#include <cstdint>
#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <vector>

#include "absl/cleanup/cleanup.h"
#include "absl/status/status.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/str_format.h"
#include "absl/strings/string_view.h"
#include "absl/types/optional.h"
#include "include/nlohmann/json.hpp"
#include "include/nlohmann/json_fwd.hpp"

namespace google {
namespace fhir {
namespace internal {

namespace {

class JsonSaxHandler {
 public:
  explicit JsonSaxHandler(FhirJson* root) { element_stack_.emplace_back(root); }

  /*!
  @brief a null value was read
  @return whether parsing should proceed
  */
  bool null() {
    const std::string token = "null";
    auto set_prev_token = absl::MakeCleanup(StorePreviousTokenCallback(token));
    return HandleValue(FhirJson::CreateNull(), /*val_is_complete=*/true);
  }

  /*!
  @brief a boolean value was read
  @param[in] val  boolean value
  @return whether parsing should proceed
  */
  bool boolean(bool val) {
    const std::string token = absl::StrCat("boolean(", val, ")");
    auto set_prev_token = absl::MakeCleanup(StorePreviousTokenCallback(token));
    return HandleValue(FhirJson::CreateBoolean(val), /*val_is_complete=*/true);
  }

  /*!
  @brief an integer number was read
  @param[in] val  integer value
  @return whether parsing should proceed
  */
  bool number_integer(int64_t val) {
    const std::string token = absl::StrCat("integer(", val, ")");
    auto set_prev_token = absl::MakeCleanup(StorePreviousTokenCallback(token));
    return HandleValue(FhirJson::CreateInteger(val), /*val_is_complete=*/true);
  }

  /*!
  @brief an unsigned integer number was read
  @param[in] val  unsigned integer value
  @return whether parsing should proceed
  */
  bool number_unsigned(uint64_t val) {
    const std::string token = absl::StrCat("unsigned(", val, ")");
    auto set_prev_token = absl::MakeCleanup(StorePreviousTokenCallback(token));
    return HandleValue(FhirJson::CreateUnsigned(val), /*val_is_complete=*/true);
  }

  /*!
  @brief an floating-point number was read
  @param[in] val  floating-point value
  @param[in] s    raw token value
  @return whether parsing should proceed
  */
  bool number_float(double val, const std::string& s) {
    const std::string token = absl::StrCat("float(", s, ")");
    auto set_prev_token = absl::MakeCleanup(StorePreviousTokenCallback(token));
    return HandleValue(FhirJson::CreateDecimal(s), /*val_is_complete=*/true);
  }

  /*!
  @brief a string was read
  @param[in] val  string value
  @return whether parsing should proceed
  @note It is safe to move the passed string.
  */
  bool string(const std::string& val) {
    const std::string token = absl::StrCat("string(", val, ")");
    auto set_prev_token = absl::MakeCleanup(StorePreviousTokenCallback(token));
    return HandleValue(FhirJson::CreateString(val), /*val_is_complete=*/true);
  }

  /*!
  @brief a binary string was read
  @param[in] val  binary value
  @return false
  @note The parser does not parse objects generated by binary value back to
  binary values, see
  https://json.nlohmann.me/features/binary_values/#json
  */
  bool binary(const std::vector<std::uint8_t>& val) {
    const std::string token =
        absl::StrCat("binary(", std::string(val.begin(), val.end()), ")");
    auto set_prev_token = absl::MakeCleanup(StorePreviousTokenCallback(token));
    status_ = absl::UnimplementedError("binary type is not supported");
    return false;
  }

  /*!
  @brief the beginning of an object was read
  @param[in] elements  number of object elements or -1 if unknown
  @return whether parsing should proceed
  @note binary formats may report the number of elements
  */
  bool start_object(std::size_t elements) {
    const std::string token = "start_object";
    auto set_prev_token = absl::MakeCleanup(StorePreviousTokenCallback(token));
    return HandleValue(FhirJson::CreateObject(),
                       /*val_is_complete=*/false);
  }

  /*!
  @brief an object key was read
  @param[in] val  object key
  @return whether parsing should proceed
  @note It is safe to move the passed string.
  */
  bool key(const std::string& val) {
    const std::string token = absl::StrCat("key(", val, ")");
    auto set_prev_token = absl::MakeCleanup(StorePreviousTokenCallback(token));
    if (element_stack_.empty()) {
      UpdateError(token, "EOF");
      return false;
    }
    if (!element_stack_.back()->isObject()) {
      UpdateError(token);
      return false;
    }
    auto new_json = element_stack_.back()->mutableValueForKey(val);
    if (!new_json.ok()) {
      UpdateError(new_json.status());
      return false;
    }
    element_stack_.emplace_back(new_json.value());
    return true;
  }

  /*!
  @brief the end of an object was read
  @return whether parsing should proceed
  */
  bool end_object() {
    const std::string token = "end_object";
    auto set_prev_token = absl::MakeCleanup(StorePreviousTokenCallback(token));
    if (element_stack_.empty()) {
      UpdateError(token, "EOF");
      return false;
    }
    if (!element_stack_.back()->isObject()) {
      UpdateError(token);
      return false;
    }
    element_stack_.pop_back();
    return true;
  }

  /*!
  @brief the beginning of an array was read
  @param[in] elements  number of array elements or -1 if unknown
  @return whether parsing should proceed
  @note binary formats may report the number of elements
  */
  bool start_array(std::size_t elements) {
    // Note `elements` is found to be -1 (in 64-bit representation) in testing.
    // Hence we are ignoring `elements` since it is not necessary for array
    // implementation.
    const std::string token = "start_array";
    auto set_prev_token = absl::MakeCleanup(StorePreviousTokenCallback(token));
    return HandleValue(FhirJson::CreateArray(),
                       /*val_is_complete=*/false);
  }

  /*!
  @brief the end of an array was read
  @return whether parsing should proceed
  */
  bool end_array() {
    const std::string token = "end_array";
    auto set_prev_token = absl::MakeCleanup(StorePreviousTokenCallback(token));
    if (element_stack_.empty()) {
      UpdateError(token, "EOF");
      return false;
    }
    if (!element_stack_.back()->isArray()) {
      UpdateError(token);
      return false;
    }
    element_stack_.pop_back();
    return true;
  }

  /*!
  @brief a parse error occurred
  @param[in] position    the position in the input where the error occurs
  @param[in] last_token  the last read token
  @param[in] ex          an exception object describing the error
  @return whether parsing should proceed (must return false)
  */
  bool parse_error(std::size_t position, const std::string& last_token,
                   const nlohmann::detail::exception& ex) {
    status_ = absl::InvalidArgumentError(
        absl::StrFormat("Encountered parse_error at position %d, last_token "
                        "`%s`, and message `%s`",
                        position, last_token, ex.what()));
    return false;
  }

  // Returns whether we finished parsing the root element.
  bool stack_empty() const { return element_stack_.empty(); }

  // Returns the latest error encountered during parsing.
  absl::Status status() const { return status_; }

 private:
  // Front of the stack (index 0) contains the root element, back/top of the
  // stack contains the current element being parsed.
  // Note: we chose to use std::vector instead of std::stack since the root
  // element is potentially useful for error message and debug information.
  std::vector<FhirJson*> element_stack_;

  // Hold error status encountered by json parser.
  absl::Status status_;

  // Store the previous token for purposes of constructing a more informative
  // error message, when needed.
  std::string previous_token_;

  // Function to be called when token processing function goes out of scope.
  std::function<void()> StorePreviousTokenCallback(const std::string& token) {
    return [this, token] { this->previous_token_ = token; };
  }

  // Common method for handling any value type as they are parsed, updates
  // the `status_` and returns false if the value cannot be handled correctly.
  // "start_object" and "start_array" are also regarded as values to be handled
  // here, but are not "complete" values.
  bool HandleValue(std::unique_ptr<FhirJson> val, bool val_is_complete) {
    if (element_stack_.empty()) {
      UpdateError(val->toString(), "EOF");
      return false;
    }
    // If current element is an array, append an empty value to be modified
    // later.
    if (element_stack_.back()->isArray()) {
      auto new_json = element_stack_.back()->mutableValueToAppend();
      if (!new_json.ok()) {
        UpdateError(new_json.status());
        return false;
      }
      element_stack_.emplace_back(new_json.value());
    }
    auto status = element_stack_.back()->MoveFrom(std::move(val));
    if (!status.ok()) {
      UpdateError(status);
      return false;
    }
    if (val_is_complete) {
      element_stack_.pop_back();
    }
    return true;
  }

  // Update `status_` with appropriate invalid argument error, incorporating
  // `actual_token` received and `expected_token` if exists.
  void UpdateError(
      const std::string& actual_token,
      const absl::optional<std::string>& expected_token = absl::nullopt) {
    std::string error_message =
        absl::StrFormat("Unexpected `%s`", actual_token);
    if (expected_token) {
      absl::StrAppend(&error_message, ", expected ", expected_token.value());
    }
    if (!element_stack_.empty()) {
      absl::StrAppend(&error_message, ", current element type is ",
                      element_stack_.back()->typeString());
    }
    if (!previous_token_.empty()) {
      absl::StrAppend(&error_message, ", previous token is ", previous_token_);
    }
    status_ = absl::InvalidArgumentError(error_message);
  }

  void UpdateError(absl::Status status) { status_ = status; }
};

}  // namespace

absl::Status ParseJsonValue(
    const absl::string_view raw_json, FhirJson& json_value) {
  JsonSaxHandler sax_handler(&json_value);

  if (nlohmann::json::sax_parse(raw_json, &sax_handler)) {
    if (sax_handler.stack_empty()) {
      return absl::OkStatus();
    }
    return absl::InvalidArgumentError(
        "Unexpected EOF, possibly due to unmatched brackets");
  }
  return sax_handler.status();
}

}  // namespace internal
}  // namespace fhir
}  // namespace google
